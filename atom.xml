<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rhizophora.github.io/</id>
    <title>Hello啊，树哥</title>
    <updated>2020-05-07T09:04:48.910Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rhizophora.github.io/"/>
    <link rel="self" href="https://rhizophora.github.io/atom.xml"/>
    <subtitle>好好学习，天天向上</subtitle>
    <logo>https://rhizophora.github.io/images/avatar.png</logo>
    <icon>https://rhizophora.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Hello啊，树哥</rights>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记八-Lambda表达式]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-ba-lambda-biao-da-shi/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-ba-lambda-biao-da-shi/">
        </link>
        <updated>2020-05-07T09:03:31.000Z</updated>
        <content type="html"><![CDATA[<p>说起lambda得先从kotlin高阶函数说起。</p>
<p>java里，如果有a方法需要调用b方法，你在里面调用就可以：</p>
<pre><code class="language-kotlin">int a() {
  return b(1);
}
a();
</code></pre>
<p>而如果你想在a调用时动态设置b方法的参数，你就得把参数传给a,再从a的内部把参数传给b:</p>
<pre><code class="language-kotlin">int a(int param) {
  return b(param);
}
a(1); // 内部调用 b(1)
a(2); // 内部调用 b(2)
</code></pre>
<p>不过如果想动态设置的不是方法参数，而是方法本身呢？</p>
<p>如我在 a 的内部有一处对别的方法的调用，这个方法可能是 b，可能是 c，不一定是谁，我只知道，我在这里有一个调用，它的参数类型是 int ，返回值类型也是 int ，而具体在 a 执行的时候内部调用哪个方法，我希望可以动态设置</p>
<pre><code class="language-kotlin">int a(??? method) {
  return method(1);
}
a(method1);
a(method2);
</code></pre>
<p>现在我想把方法作为参数传到另一个方法里，这个该怎么做？</p>
<p>在java里是不允许把方法作为参数传递的，但是我们有一个历史悠久的变通方案：接口。</p>
<p>我们可以通过接口的方式把方法包装起来：</p>
<pre><code class="language-java">public interface Wrapper {
  int method(int param);
}
</code></pre>
<p>然后把这个接口的类型作为外部方法的参数类型：</p>
<pre><code class="language-java">int a(Wrapper wrapper) {
  return wrapper.method(1);
}
</code></pre>
<p>在调用外部方法时，传递接口的对象来作为参数：</p>
<pre><code class="language-java">a(wrapper1);
a(wrapper2);
</code></pre>
<p>这里再换个写法感受下：</p>
<p>在用户发生点击行为的时候会触发点击事件：</p>
<pre><code class="language-java">// 注：这是简化后的代码，不是 View.java 类的源码
public class View {
  OnClickListener mOnClickListener;
  ...
  public void onTouchEvent(MotionEvent e) {
    ...
    mOnClickListener.onClick(this);
    ...
  }
}
</code></pre>
<p>所谓的点击事件，最核心的内容就是调用内部的一个OnClickListener的onClick()方法：</p>
<pre><code class="language-java">public interface OnClickListener {
  void onClick(View v);
}
</code></pre>
<p>而所谓的这个OnClickListener其实只是一个壳，它的核心全在内部那个onClick()方法。换句话说，我们传过来一个OnClickListener：</p>
<pre><code class="language-java">OnClickListener listener1 = new OnClickListener() {
  @Override
  void onClick(View v) {
    doSomething();
  }
};
view.setOnClickListener(listener1);
</code></pre>
<p>本质上其实是传过来一个可以在稍后被调用的方法（onClick()）。只不过因为java不允许传递方法，所以我们才把它包进了一对象里来进行传递。</p>
<p>而在Kotlin里面，函数的参数也可以是函数类型的：</p>
<pre><code class="language-kotlin">fun a(funParam: Fun): String {
  return funParam(1);
}
</code></pre>
<p>当一个函数含有函数类型的参数的时候，如果你调用它，你就可以当然你也必须传入一个函数类型的对象给它。</p>
<pre><code class="language-kotlin">fun b(param: Int): String {
  return param.toString()
}
a(b)
</code></pre>
<p>不过具体写法不是这样的，这只是举例。</p>
<p>首先这个Fun作为函数类型其实是错的，Kotlin里并没有这么一种类型来标记这个类型是个函数类型。因为函数类型不是一「个」类型，而是一「类」类型，因为函数类型可以有各种各样不同的参数和返回值的类型的搭配，这些搭配属于不同的函数类型。例如，无参数无返回值（() -&gt; Unit）和单 Int 型参数返回 String （Int -&gt; String）是两种不同的类型，这个很好理解，就好像 Int 和 String 是两个不同的类型。所以不能只用 Fun 这个词来表示「这个参数是个函数类型」，就好像不能用 Class 这个词来表示「这个参数是某个类」，因为你需要指定，具体是哪种函数类型，或者说这个函数类型的参数，它的参数类型是什么、返回值类型是什么，而不能笼统地一句说「它是函数类型」就完了。</p>
<p>所以对于函数类型的参数，需要指明他有几个参数、参数的类型是什么以及返回值类型是什么，那么差不多就是这么写：</p>
<pre><code class="language-kotlin">fun a(funParam: (Int) -&gt; String): String {
  return funParam(1)
}
</code></pre>
<p>只有这样写，调用的人才知道应该传一个怎样的函数类型的参数给你。</p>
<p>同样的，函数类型不只可以作为函数的参数类型，还可以作为函数的返回值类型</p>
<pre><code class="language-kotlin">fun c(param: Int): (Int) -&gt; Unit {
  ...
}
</code></pre>
<p>这种参数或者返回值为函数类型的函数，在kotlin中就被称为高阶函数。</p>
<p>Kotlin 里，这种参数有函数类型或者返回值是函数类型的函数，都叫做高阶函数，这只是个对这一类函数的称呼，没有任何特殊性，Kotlin 的高阶函数没有任何特殊功能。</p>
<p>另外，函数类型除了作为函数的参数和返回值类型，你把它赋值给一个变量也是可以的。</p>
<p>不过对于一个声明好的函数，不管是你要把它作为参数传递给函数，还是要把它赋值给变量，都得在函数名的左边加上双冒号才行：</p>
<pre><code class="language-kotlin">a(::b)
val d = ::b
</code></pre>
<p>双冒号::method，这种写法kotlin官方叫做函数引用。因为加了两个冒号，这函数才变成了一个对象。</p>
<p>Kotlin里函数可以作为参数这件事的本质，是函数在kotlin里可以作为对象存在，因为只有对象才能被作为参数传递。赋值也是一样的道理，只有对象才能被赋值给变量。但Kotlin的函数本身的性质又决定了它没办法被当做一个对象，那就创建一个和函数具有相同功能的对象，使用双冒号。</p>
<p>在kotlin里，一个函数名的左边加上双冒号，它就不表示这个函数本身了，而表示一个对象，或者说一个指定对象的引用，但，这个对象可不是函数本身，而是一个和这个函数具有相同功能的对象。</p>
<p>怎么个相同法呢？你可以怎么用函数，就能怎么用这个加了双冒号的对象：</p>
<pre><code class="language-kotlin">b(1) // 调用函数
d(1) // 用对象 a 后面加上括号来实现 b() 的等价操作
(::b)(1) // 用对象 :b 后面加上括号来实现 b() 的等价操作
</code></pre>
<p>再强调一遍，这个双冒号的东西，它不是一个函数，而是一个对象，一个函数类型的对象。</p>
<p>对象是不能加个括号来调用的，但是函数类型的对象可以。因为这个其实是个假的调用，它是kotlin的语法糖，实际上你对一个函数类型的对象加括号、加参数，它真正调用的是这个对象的invoke()函数：</p>
<pre><code class="language-kotlin">d(1) // 实际上会调用 d.invoke(1)
(::b)(1) // 实际上会调用 (::b).invoke(1)
</code></pre>
<p>所以你可以对一个函数类型的对象调用invoke(),但不能对一个函数这么做：</p>
<pre><code class="language-kotlin">b.invoke(1) // 报错
</code></pre>
<p>因为只有函数类型的对象有这个自带的invoke()可以用，而函数，不是函数类型的对象。它什么类型也不是。函数不是对象， 它也没有类型，函数就是函数，它和对象是两个维度的东西。</p>
<p>包括双冒号加上函数名的这个写法，它是一个指向对象的引用，但并不是指向函数本身，而是指向一个我们在代码里看不见的对象。这个对象复制了原函数的功能，但它并不是原函数。</p>
<p>举个例子</p>
<pre><code class="language-kotlin">fun b(param: Int): String {
  return param.toString()
}
val d = ::b
</code></pre>
<p>那我如果想把 d 赋值给一个新的变量 e：</p>
<pre><code class="language-kotlin">val e = d
</code></pre>
<p>我等号右边的 d，应该加双冒号还是不加呢？</p>
<p>当然不用加双冒号了 d已经被赋值为对象了，所以直接写就行了。</p>
<p>匿名函数</p>
<p>要穿一个函数类型的参数，或者把一个函数类型的对象赋值给变量 ，除了用双冒号来拿现成的函数使用，你还可以直接把这个函数挪过来写：</p>
<pre><code class="language-kotlin">a(fun b(param: Int): String {
  return param.toString()
});
val d = fun b(param: Int): String {
  return param.toString()
}
</code></pre>
<p>另外这种写法的话，函数的名字其实就没用了，所以可以省略掉：</p>
<pre><code class="language-kotlin">a(fun(param: Int): String {
  return param.toString()
});
val d = fun(param: Int): String {
  return param.toString()
}
</code></pre>
<p>这种写法就叫做匿名函数。因为没有名字。</p>
<p>另外，其实刚刚那种左边右边都有名字的写法，kotlin是不允许的。右边的函数既然要名字也没有用，kotlin干脆就不许它有名字了。</p>
<p>所以，java的回调：</p>
<pre><code class="language-java">public interface OnClickListener {
  void onClick(View v);
}
public void setOnClickListener(OnClickListener listener) {
  this.listener = listener;
}
</code></pre>
<pre><code class="language-java">view.setOnClickListener(new OnClickListener() {
  @Override
  void onClick(View v) {
    switchToNextPage();
  }
});
</code></pre>
<p>kotlin的写法：</p>
<pre><code class="language-kotlin">fun setOnClickListener(onClick: (View) -&gt; Unit) {
  this.onClick = onClick
}
view.setOnClickListener(fun(v: View): Unit) {
  switchToNextPage()
})
</code></pre>
<p>另外几乎所有情况下，匿名函数还能更简化一点，写成lambda表达式的形式：</p>
<pre><code class="language-kotlin">view.setOnClickListener({ v: View -&gt;
  switchToNextPage()
})
</code></pre>
<p>lambda表达式：</p>
<p>如果lambda是函数的最后一个参数，你可以把lambda写在括号的外面：</p>
<pre><code class="language-kotlin">view.setOnClickListener() { v: View -&gt;
  switchToNextPage()
}
</code></pre>
<p>如果lambda是函数唯一的参数，还可以直接把括号去掉：</p>
<pre><code class="language-kotlin">view.setOnClickListener { v: View -&gt;
  switchToNextPage()
}
</code></pre>
<p>另外，如果这个lambda是单参数的，它的参数也省略掉不写：</p>
<pre><code class="language-kotlin">view.setOnClickListener {
  switchToNextPage()
}
</code></pre>
<p>单参数的时候，kotlin的lambda对它们有默认的名字: it</p>
<p>有点爽哈？不过我们先停下想一想：这个 Lambda 这也不写那也不写的……它不迷茫吗？它是怎么知道自己的参数类型和返回值类型的？</p>
<p>靠上下文的推断。我调用的函数在声明的地方有明确的参数信息吧？</p>
<pre><code class="language-kotlin">fun setOnClickListener(onClick: (View) -&gt; Unit) {
  this.onClick = onClick
}
</code></pre>
<p>这里面把这个参数的参数类型和返回值写得清清楚楚吧？所以 Lambda 才不用写的。</p>
<p>所以，当你要把一个匿名函数赋值给变量而不是作为函数参数传递的时候：</p>
<pre><code class="language-kotlin">val b = fun(param: Int): String {
  return param.toString()
}
</code></pre>
<p>如果也简写成 Lambda 的形式：</p>
<pre><code class="language-kotlin">val b = { param: Int -&gt;
  return param.toString()
}
</code></pre>
<p>就不能省略掉 Lambda 的参数类型了：</p>
<pre><code class="language-kotlin">val b = {
  return it.toString() // it 报错
}
</code></pre>
<p>因为它无法从上下文中推断出这个参数的类型啊！</p>
<p>如果你出于场景的需求或者个人偏好，就是想在这里省掉参数类型，那你需要给左边的变量指明类型：</p>
<pre><code class="language-kotlin">val b: (Int) -&gt; String = {
  return it.toString() // it 可以被推断出是 Int 类型
}
</code></pre>
<p>另外 Lambda 的返回值不是用 return 来返回，而是直接取最后一行代码的值：</p>
<pre><code class="language-kotlin">val b: (Int) -&gt; String = {
  it.toString() // it 可以被推断出是 Int 类型
}
</code></pre>
<p>这个一定注意，Lambda 的返回值别写 return，如果你写了，它会把这个作为它外层的函数的返回值来直接结束外层函数。当然如果你就是想这么做那没问题啊，但如果你是只是想返回 Lambda，这么写就出错了。</p>
<p>另外因为 Lambda 是个代码块，它总能根据最后一行代码来推断出返回值类型，所以它的返回值类型确实可以不写。实际上，Kotlin 的 Lambda 也是写不了返回值类型的，语法上就不支持。</p>
<p>Kotlin里匿名函数和Lambda表达式的本质</p>
<p>匿名函数可以作为参数传递，也可以赋值给变量。</p>
<p>但是函数是不能作为参数传递，也不能赋值给变量的。</p>
<p>匿名函数就是这么特殊，因为kotlin的匿名函数不是函数，它是个对象。匿名函数虽然名字里有函数两个字，但它其实不是函数，而是一个对象，一个函数类型的对象。她和双冒号加函数名是一类东西，和函数不是。</p>
<p>所以，你才可以直接把它当做函数的参数来传递以及赋值给变量 ：</p>
<pre><code class="language-kotlin">a(fun (param: Int): String {
  return param.toString()
});
val a = fun (param: Int): String {
  return param.toString()
}
</code></pre>
<p>同理，lambda其实也是一个函数类型的对象而已。你能怎么使用双冒号加函数名，就能怎么使用匿名函数，以及怎么使用lambda表达式。</p>
<p>这就是匿名函数和lambda表达式的本质，它们都是函数类型的对象。kotlin的lambda跟java的lambda是不一样的，java8的lambda只是一种便捷写法，本质上并没有功能上的突破，而kotlin的lambda是实实在在的对象。</p>
<p>在你知道了在kotlin里函数并不能传递，传递的是对象和匿名函数和lambda表达式其实都是对象 这些本质后，再去写kotlin的高阶函数会轻松许多。</p>
<p>Java 8 允许你用 Lambda 表达式来创建匿名类对象，但它本质上还是在创建一个匿名类对象，只是一种简化写法而已，所以 Java 的 Lambda 只靠代码自动补全就基本上能写了。而 Kotlin 里的 Lambda 和 Java 本质上就是不同的，因为 Kotlin 的 Lambda 是实实在在的函数类型的对象，功能更强，写法更多更灵活。</p>
<p>另外呢，Kotlin 是不支持使用 Lambda 的方式来简写匿名类对象的，因为我们有函数类型的参数嘛，所以这种单函数接口的写法就直接没必要了。那你还支持它干嘛？</p>
<p>不过当和 Java 交互的时候，Kotlin 是支持这种用法的：当你的函数参数是 Java 的单抽象方法的接口的时候，你依然可以使用 Lambda 来写参数。但这其实也不是 Kotlin <strong>增加</strong>了功能，而是对于来自 Java 的单抽象方法的接口，Kotlin 会为它们额外创建一个把参数替换为函数类型的桥接方法，让你可以间接地创建 Java 的匿名类对象。</p>
<p>这就是为什么，你会发现当你在 Kotlin 里调用 View.java 这个类的 setOnClickListener() 的时候，可以传 Lambda 给它来创建 OnClickListener 对象，但你照着同样的写法写一个 Kotlin 的接口，你却不能传 Lambda。因为 Kotlin 期望我们直接使用函数类型的参数，而不是用接口这种折中方案。</p>
<p>好，这就是 Kotlin 的高阶函数、匿名函数和 Lambda。简单总结一下：</p>
<ul>
<li>在 Kotlin 里，有一类 Java 中不存在的类型，叫做「函数类型」，这一类类型的对象在可以当函数来用的同时，还能作为函数的参数、函数的返回值以及赋值给变量；</li>
<li>创建一个函数类型的对象有三种方式：双冒号加函数名、匿名函数和 Lambda；</li>
<li>一定要记住：双冒号加函数名、匿名函数和 Lambda 本质上都是函数类型的对象。在 Kotlin 里，匿名函数不是函数，Lambda 也不是什么玄学的所谓「它只是个代码块，没法归类」，Kotlin 的 Lambda 可以归类，它属于函数类型的对象。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记七-非阻塞式挂起]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-qi-fei-zu-sai-shi-gua-qi/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-qi-fei-zu-sai-shi-gua-qi/">
        </link>
        <updated>2020-05-06T11:49:06.000Z</updated>
        <content type="html"><![CDATA[<p>非阻塞式是相对阻塞式而言的。</p>
<p>编程语言中的很多概念其实都来源于生活，就像脱口秀的段子一样。</p>
<p>线程阻塞很好理解，现实中的例子就是交通堵塞，它的核心有 3 点：</p>
<ul>
<li>前面有障碍物，你过不去（线程卡了）</li>
<li>需要等障碍物清除后才能过去（耗时任务结束）</li>
<li>除非你绕道而行（切到别的线程）</li>
</ul>
<p>从语义上理解「非阻塞式挂起」，讲的是「非阻塞式」这个是挂起的一个特点，也就是说，协程的挂起，就是非阻塞式的，协程是不讲「阻塞式的挂起」的概念的。</p>
<p>我们讲「非阻塞式挂起」，其实它有几个前提：并没有限定在一个线程里说这件事，因为挂起这件事，本来就是涉及到多线程。</p>
<p>阻塞不阻塞，都是针对单线程讲的，一旦切了线程，肯定是非阻塞的，你都跑到别的线程了，之前的线程就自由了，可以继续做别的事情了。</p>
<p>所以「非阻塞式挂起」，其实就是在讲协程在挂起的同时切线程这件事情。</p>
<pre><code class="language-kotlin">main {
    GlobalScope.launch(Dispatchers.Main) {
        // 👇 耗时操作
        val user = suspendingRequestUser()
        updateView(user)
    }
    
    private suspend fun suspendingRequestUser() : User = withContext(Dispatchers.IO) {
        api.requestUser()
    }
}
</code></pre>
<p>从上面的例子可以看到，耗时操作和更新 UI 的逻辑像写单线程一样放在了一起，只是在外面包了一层协程。</p>
<p>而正是这个协程解决了原来我们单线程写法会卡线程这件事。</p>
<p>阻塞的本质</p>
<p>首先，所有的代码本质上都是阻塞式的，而只有比较耗时的代码才会导致人类可感知的等待，比如在主线程上做一个耗时 50 ms 的操作会导致界面卡掉几帧，这种是我们人眼能观察出来的，而这就是我们通常意义所说的「阻塞」。</p>
<p>举个例子，当你开发的 app 在性能好的手机上很流畅，在性能差的老手机上会卡顿，就是在说同一行代码执行的时间不一样。</p>
<p>视频中讲了一个网络 IO 的例子，IO 阻塞更多是反映在「等」这件事情上，它的性能瓶颈是和网络的数据交换，你切多少个线程都没用，该花的时间一点都少不了。</p>
<p>而这跟协程半毛钱关系没有，切线程解决不了的事情，协程也解决不了。</p>
<p>协程与线程</p>
<p>在 Kotlin 里，协程就是基于线程来实现的一种更上层的工具 API，类似于 Java 自带的 Executor 系列 API 或者 Android 的 Handler 系列 API。</p>
<p>只不过呢，协程它不仅提供了方便的 API，在设计思想上是一个<strong>基于线程的上层框架</strong>，你可以理解为新造了一些概念用来帮助你更好地使用这些 API，仅此而已。</p>
<ul>
<li>协程就是切线程；</li>
<li>挂起就是可以自动切回来的切线程；</li>
<li>挂起的非阻塞式指的是它能用看起来阻塞的代码写出非阻塞的操作，就这么简单。</li>
</ul>
<p>Kotlin 协程并没有脱离 Kotlin 或者 JVM 创造新的东西，它只是将多线程的开发变得更简单了，可以说是因为 Kotlin 的诞生而顺其自然出现的东西，从语法上看它很神奇，但从原理上讲，它并不是魔术。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记六-协程的挂起]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-liu-xie-cheng-de-gua-qi/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-liu-xie-cheng-de-gua-qi/">
        </link>
        <updated>2020-05-06T11:01:58.000Z</updated>
        <content type="html"><![CDATA[<p>大部分情况下，我们都是用launch函数来创建协程，其实还有其他两个函数也可以来创建协程：</p>
<p>runBlocking：通常适用于单元测试的场景，而业务开发中不会用到这个函数，因为它是线程阻塞的。</p>
<p>async：和launch相同点是都可以用来启动一个协程，返回的都是Coroutine,不同点是 async返回的Coroutine多实现了Deferred接口。</p>
<p>Deferred的意思就是延迟，也就是结果稍后才能拿到。</p>
<p>我们调用Deferred.await()就可以得到结果了。</p>
<p>async的使用：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {
    //                      👇  async 函数启动新的协程
    val avatar: Deferred = async { api.getAvatar(user) }    // 获取用户头像
    val logo: Deferred = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo
    //            👇          👇 获取返回值
    show(avatar.await(), logo.await())                     // 更新 UI
}
</code></pre>
<p>可以看到avatar和logo的类型都可以声明为Deferred，通过await获取结果并且更新到Ui上显示。</p>
<p>挂起的本质</p>
<p>协程中挂起的对象其实是协程。</p>
<p>协程其实就是launch或者async函数中闭包的代码块。</p>
<p>launch，async或者其他函数创建的协程，在执行到某一个suspend函数的时候，这个协程会被suspend,也就是被挂起。从当前线程挂起。也就是这个协程从正在执行它的线程上脱离。</p>
<p>这个脱离并不是协程停下来了，而是当前线程不再管这个协程干嘛去了。</p>
<p>suspend是有暂停的意思，但我们在协程中应该理解为：当线程执行到协程的suspend函数的时候，暂时不继续执行协程代码了。</p>
<p>那就从这两个互相脱离的协程和线程分析接下来发生的事情：</p>
<p>线程：</p>
<p>前面提到，挂起会让协程从正在执行它的线程上脱离，具体到代码就是：</p>
<p>协程的代码块中，线程执行到了suspend函数这里的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。</p>
<p>那这个线程，如果是一个后台线程，要么无事可做，被系统回收；要么继续执行别的后台任务，跟java线程池里的线程在工作结束之后是完全一样的：回收或者再利用。</p>
<p>如果这个线程是一个主线程，那它接下来就会继续回去工作:也就是一秒钟60次的界面刷新任务。</p>
<p>协程：</p>
<p>线程的代码在到达suspend函数的时候被掐断，接下来协程会从这个suspend函数开始继续往下执行，不过是在指定的线程。</p>
<p>是suspend函数指定的，之前的例子就是函数内部的withContext传入的Dispatchers.IO所指定的IO线程。</p>
<p>Dispatchers调度器，他可以将协程限制在一个指定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行。</p>
<p>日常用的调度器Dispatchers有三种：</p>
<p>Dispatchers.Main:Android主线程</p>
<p>Dispatchers.IO:针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如:读写文件，操作数据库以及网络请求</p>
<p>Dispatchers.Default:适合CPU密集型的任务，比如计算。</p>
<p>协程它从suspend函数开始脱离启动它的线程，继续执行在Dispatchers所指定的IO线程。</p>
<p>紧接着在suspend函数执行完成后，协程就会自动帮我们把线程再切回来。</p>
<p>我们协程原本是运行在主线程的，当代码遇到suspend函数的时候，发生线程切换，根据Dispatchers切换到了IO线程；</p>
<p>当这个函数执行完毕后，线程又切回来了，切回来也就是协程会帮我们再post一个runnable，让我剩下的代码继续回到主线程去执行。</p>
<p>协程在执行到有suspend标记函数的时候，会被suspend也就是被挂起，而所谓的被挂起，就是切个线程；</p>
<p>不过区别在于，挂起函数在执行完成后，协程会重新切回它原先的线程。</p>
<p>更简单的说法就是：在kotlin中所谓的挂起，就是一个稍后会被自动切回来的线程调度操作。</p>
<p>这个切回来的动作，在kotlon中叫做resume，恢复。</p>
<p>挂起后是需要恢复的。而恢复这个功能是协程的，如果你不在协程里面调用，恢复这个功能没法实现，所以也就回答了这个问题：为什么挂起函数必须在协程或者另一个挂起函数里被调用。</p>
<p>所以，要求 <code>suspend</code> 函数只能在协程里或者另一个 suspend 函数里被调用，还是为了要让协程能够在 <code>suspend</code> 函数切换线程之后再切回来。</p>
<p>suspend的意义</p>
<p><strong>它其实是一个提醒。</strong></p>
<p>函数的创建者对函数的使用者的提醒：我是一个耗时函数，我被我的创建者用挂起的方式放在后台运行，所以请在协程里调用我。</p>
<p>为什么 <code>suspend</code> 关键字并没有实际去操作挂起，但 Kotlin 却把它提供出来？</p>
<p>因为它本来就不是用来操作挂起的。</p>
<p>挂起的操作 —— 也就是切线程，依赖的是挂起函数里面的实际代码，而不是这个关键字。</p>
<p>所以这个关键字，<strong>只是一个提醒</strong>。</p>
<pre><code class="language-kotlin">// 👇 redundant suspend modifier
suspend fun suspendingPrint() {
  println(&quot;Thread: ${Thread.currentThread().name}&quot;)
}
</code></pre>
<p>如果你创建一个 <code>suspend</code> 函数但它内部不包含真正的挂起逻辑，编译器会给你一个提醒：<code>redundant suspend modifier</code>，告诉你这个 <code>suspend</code> 是多余的。</p>
<p>因为你这个函数实质上并没有发生挂起，那你这个 <code>suspend</code> 关键字只有一个效果：就是限制这个函数只能在协程里被调用，如果在非协程的代码中调用，就会编译不通过。</p>
<p>所以，创建一个 <code>suspend</code> 函数，为了让它包含真正挂起的逻辑，要在它内部直接或间接调用 Kotlin 自带的 <code>suspend</code> 函数，你的这个 <code>suspend</code> 才是有意义的。</p>
<p>怎么自定义suspend函数</p>
<p>在了解了 <code>suspend</code> 关键字的来龙去脉之后，我们就可以进入下一个话题了：怎么自定义 <code>suspend</code> 函数。</p>
<p>这个「怎么自定义」其实分为两个问题：</p>
<ul>
<li>什么时候需要自定义 <code>suspend</code> 函数？</li>
<li>具体该怎么写呢？</li>
</ul>
<p>自定义suspend函数的时候</p>
<p>如果你的某个函数比较耗时，也就是要等的操作，那就把它写成 <code>suspend</code> 函数。这就是原则。</p>
<p>耗时操作一般分为两类：I/O 操作和 CPU 计算工作。比如文件的读写、网络交互、图片的模糊处理，都是耗时的，通通可以把它们写进 <code>suspend</code> 函数里。</p>
<p>另外这个「耗时」还有一种特殊情况，就是这件事本身做起来并不慢，但它需要等待，比如 5 秒钟之后再做这个操作。这种也是 <code>suspend</code> 函数的应用场景。</p>
<p>具体写法</p>
<p>给函数加上 <code>suspend</code> 关键字，然后在 <code>withContext</code> 把函数的内容包住就可以了。</p>
<p>提到用 <code>withContext</code>是因为它在挂起函数里功能最简单直接：把线程自动切走和切回。</p>
<p>当然并不是只有 <code>withContext</code> 这一个函数来辅助我们实现自定义的 <code>suspend</code> 函数，比如还有一个挂起函数叫 <code>delay</code>，它的作用是等待一段时间后再继续往下执行代码。</p>
<p>使用它就可以实现刚才提到的等待类型的耗时操作：</p>
<pre><code class="language-kotlin">suspend fun suspendUntilDone() {
  while (!done) {
    delay(5)
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记五-协程]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-wu-xie-cheng/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-wu-xie-cheng/">
        </link>
        <updated>2020-04-30T14:32:58.000Z</updated>
        <content type="html"><![CDATA[<p>协程是kotlin非常特别的一部分，和java相比，它是个全新的概念。</p>
<p>协程设计的初衷就是为了解决并发问题，让协作式多任务实现起来更加方便。</p>
<p>协程是kotlin提供的一套线程封装的api,但并不是说协程就是为线程而生的。</p>
<p>使用协程进行网络请求刷新ui的例子</p>
<pre><code class="language-kotlin">launch({
    val user = api.getUser() // 👈 网络请求（IO 线程）
    nameTv.text = user.name  // 👈 更新 UI（主线程）
})
</code></pre>
<p>launch并不是一个顶层函数，它必须在一个对象中使用。launch函数加上是现在{}中的具体逻辑，就构成了一个协程。</p>
<p>协程的基本使用</p>
<pre><code class="language-kotlin">// 方法一，使用 runBlocking 顶层函数
runBlocking {
    getImage(imageId)
}

// 方法二，使用 GlobalScope 单例对象
//            👇 可以直接调用 launch 开启协程
GlobalScope.launch {
    getImage(imageId)
}

// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象
//                                    👇 需要一个类型为 CoroutineContext 的参数
val coroutineScope = CoroutineScope(context)
coroutineScope.launch {
    getImage(imageId)
}
</code></pre>
<p>方法一通常适用于单元测试的场景，业务开发不会用到这种方法，因为它是线程阻塞的。</p>
<p>方法二和使用runBlocking的区别在于不会阻塞线程。但是在Android开发中同样不推荐这种用法，因为它的生命周期会和app一致，而且不能取消。</p>
<p>方法三是比较推荐的使用方法，我们可以通过context参数去管理和控制协程的生命周期（这里的context和android里的不是一个东西，是一个更通用的概念，有一个android平台的封装来配合使用）。</p>
<p>协程最常用的功能是开发，而并发的典型场景就是多线程。可以使用Dispatchers.IO参数把任务切到IO线程执行。</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.IO) {
    ...
}
</code></pre>
<p>当然也可以使用Dispatchers.Main参数切换到主线程：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {
    ...
}
</code></pre>
<p>所以一个完整的异步请求例子是这样写的：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {   // 在主线程开启协程
    val user = api.getUser() // IO 线程执行网络请求
    nameTv.text = user.name  // 主线程更新 UI
}
</code></pre>
<p>java写的话就很难受</p>
<pre><code class="language-java">api.getUser(new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                nameTv.setText(user.name);
            }
        })
    }
    
    @Override
    public void failure(Exception e) {
        ...
    }
});
</code></pre>
<p>协程的1到0</p>
<p>对于回调式的写法，如果并发场景再复杂一些，代码的嵌套可能会更多，维护起来会非常麻烦。用协程就会简单太多：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {       // 开始协程：主线程
    val token = api.getToken()                  // 网络请求：IO 线程
    val user = api.getUser(token)               // 网络请求：IO 线程
    nameTv.text = user.name                     // 更新 UI：主线程
}
</code></pre>
<p>如果遇到的场景是开启多个网络请求，等待所有请求结束之后再对ui更新，利用协程可以吧两个并行请求结果合并：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {
    //            👇  async 函数之后再讲
    val avatar = async { api.getAvatar(user) }    // 获取用户头像
    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo
    val merged = suspendingMerge(avatar, logo)    // 合并结果
    //                  👆
    show(merged) // 更新 UI
}
</code></pre>
<p>需要注意的是 <code>suspendingMerge</code> 并不是协程 API 中提供的方法，而是我们自定义的一个可「挂起」的结果合并方法。</p>
<p>让复杂的并发代码，写起来变得简单且清晰，是协程的优势。</p>
<p>这里，两个没有相关性的后台任务，因为用了协程，被安排得明明白白，互相之间配合得很好，也就是「协作式任务」。</p>
<p>协程使用</p>
<p>在使用协程之前，我们需要在 <code>build.gradle</code> 文件中增加对 Kotlin 协程的依赖：</p>
<p>项目根目录下的 <code>build.gradle</code> :</p>
<pre><code class="language-groovy">buildscript {
    ...
    // 👇
    ext.kotlin_coroutines = '1.3.1'
    ...
}
</code></pre>
<p>Module 下的 <code>build.gradle</code> :</p>
<pre><code class="language-groovy">dependencies {
    ...
    //                                       👇 依赖协程核心库
    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlin_coroutines&quot;
    //                                       👇 依赖当前平台所对应的平台库
    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines&quot;
    ...
}
</code></pre>
<p>Kotlin 协程是以官方扩展库的形式进行支持的。而且，我们所使用的「核心库」和 「平台库」的版本应该保持一致。</p>
<ul>
<li>核心库中包含的代码主要是协程的公共 API 部分。有了这一层公共代码，才使得协程在各个平台上的接口得到统一。</li>
<li>平台库中包含的代码主要是协程框架在具体平台的具体实现方式。因为多线程在各个平台的实现方式是有所差异的。</li>
</ul>
<p>完成以上准备就可以开始使用协程了。</p>
<p>协程最简单的使用方法，可以通过一个 <code>launch</code> 函数实现线程切换的功能：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.IO) {
    ...
}
</code></pre>
<p>这个 <code>launch</code> 函数，它具体的含义是：我要创建一个新的协程，并在指定的线程上运行它。这个被创建、被运行的所谓「协程」是谁？就是你传给 <code>launch</code> 的那些代码，这一段连续代码叫做一个「协程」。</p>
<p>所以，什么时候用协程？当你需要切线程或者指定线程的时候。你要在后台执行任务？切！</p>
<pre><code class="language-kotlin">launch(Dispatchers.IO) {
    val image = getImage(imageId)
}
</code></pre>
<p>然后需要在前台更新界面？再切！</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.IO) {
    val image = getImage(imageId)
    launch(Dispatchers.Main) {
        avatarIv.setImageBitmap(image)
    }
}
</code></pre>
<p>好像有点不对劲？这不还是有嵌套嘛。</p>
<p>如果只是使用 <code>launch</code> 函数，协程并不能比线程做更多的事。不过协程中却有一个很实用的函数：<code>withContext</code> 。这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行。那么可以将上面的代码写成这样：</p>
<pre><code class="language-kotlin">coroutineScope.launch(Dispatchers.Main) {      // 👈 在 UI 线程开始
    val image = withContext(Dispatchers.IO) {  // 👈 切换到 IO 线程，并在执行完成后切回 UI 线程
        getImage(imageId)                      // 👈 将会运行在 IO 线程
    }
    avatarIv.setImageBitmap(image)             // 👈 回到 UI 线程更新 UI
} 
</code></pre>
<p>这种写法看上去好像和刚才那种区别不大，但如果你需要频繁地进行线程切换，这种写法的优势就会体现出来。可以参考下面的对比：</p>
<pre><code class="language-kotlin">// 第一种写法
coroutineScope.launch(Dispatchers.IO) {
    ...
    launch(Dispatchers.Main){
        ...
        launch(Dispatchers.IO) {
            ...
            launch(Dispatchers.Main) {
                ...
            }
        }
    }
}

// 通过第二种写法来实现相同的逻辑
coroutineScope.launch(Dispatchers.Main) {
    ...
    withContext(Dispatchers.IO) {
        ...
    }
    ...
    withContext(Dispatchers.IO) {
        ...
    }
    ...
}
</code></pre>
<p>由于可以&quot;自动切回来&quot;，消除了并发代码在协作时的嵌套。由于消除了嵌套关系，我们甚至可以把 <code>withContext</code> 放进一个单独的函数里面：</p>
<pre><code class="language-kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始
    val image = getImage(imageId)
    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程
}
//                               👇
fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    ...
}
</code></pre>
<p>这就是之前说的「用同步的方式写异步的代码」了。</p>
<p>不过如果只是这样写，编译器是会报错的：</p>
<pre><code class="language-kotlin">fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    // IDE 报错 Suspend function'withContext' should be called only from a coroutine or another suspend funcion
}
</code></pre>
<p>意思是说，<code>withContext</code> 是一个 <code>suspend</code> 函数，它需要在协程或者是另一个 <code>suspend</code> 函数中调用。</p>
<p>suspend</p>
<p><code>suspend</code> 是 Kotlin 协程最核心的关键字，几乎所有介绍 Kotlin 协程的文章和演讲都会提到它。它的中文意思是「暂停」或者「可挂起」。如果你去看一些技术博客或官方文档的时候，大概可以了解到：「代码执行到 <code>suspend</code> 函数的时候会『挂起』，并且这个『挂起』是非阻塞式的，它不会阻塞你当前的线程。」</p>
<p>上面报错的代码，其实只需要在前面加一个 <code>suspend</code> 就能够编译通过：</p>
<pre><code class="language-kotlin">suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {
    ...
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记四-泛型]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-si-fan-xing/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-si-fan-xing/">
        </link>
        <updated>2020-04-30T11:47:59.000Z</updated>
        <content type="html"><![CDATA[<p>kotlin的泛型，通常离不开两个关键字 in 和 out。</p>
<p>in就代表输入，可以改数据，但是不能查数据，对应的就是逆变</p>
<p>out就代表输出，可以查数据，但是不能改数据，对应的就是协变</p>
<p>泛型的意思就是把具体的类型泛化，编码的时候用符号来指代类型，在使用的时候，再确定它的类型。</p>
<pre><code class="language-java">TextView textView = new Button(context);
// 👆 这是多态

List&lt;Button&gt; buttons = new ArrayList&lt;Button&gt;();
List&lt;TextView&gt; textViews = buttons;
// 👆 多态用在这里会报错 incompatible types: List&lt;Button&gt; cannot be converted to List&lt;TextView&gt;
</code></pre>
<p>Button继承于TextView的，根据java多态，赋值是正确的。</p>
<p>但是到了ListView<TextView>这里就会报错，因为java泛型本身具有不可变性，java里面认为ListView<Textview>和List<Button>类型并不一致。也就是 子类的泛型List<Button>不属于泛型List<TextView>的子类。</p>
<p>Java 的泛型类型会在编译时发生<strong>类型擦除</strong>，为了保证类型安全，不允许这样赋值。</p>
<p>但是在 Java 里用数组做类似的事情，是不会报错的，这是因为数组并没有在编译时擦除类型：</p>
<pre><code class="language-java">TextView[] textViews = new TextView[10];
</code></pre>
<p>为了解决类似的需求，实现上面的赋值，java提供了泛型通配符  ? extends和 ? super</p>
<p>java里是这样解决的</p>
<pre><code class="language-java">List&lt;Button&gt; buttons = new ArrayList&lt;Button&gt;();
      👇
List&lt;? extends TextView&gt; textViews = buttons;
</code></pre>
<p>?extends 叫做上界通配符，可以使java泛型具有协变性，协变就是允许上面的赋值时合法的。</p>
<p>在继承关系树中，子类继承自父类，可以认为父类在上，子类在下。<code>extends</code> 限制了泛型类型的父类型，所以叫上界。</p>
<p>其中？是个通配符，表示这个List的泛型类型是个未知类型</p>
<p>extends限制了这个未知类型的上界，也就是泛型类型必须满足这个extends的限制条件，这里和定义class的extends关键字有点不一样：</p>
<p>它的范围不仅是所有直接和间接子类，还包括上界定义的父类本身，也就是TextView。</p>
<p>它还有implements的意思，即这里的上界也可以是interface。</p>
<p>所以下面这几种情况都是可以的：</p>
<pre><code class="language-java">List&lt;? extends TextView&gt; textViews = new ArrayList&lt;TextView&gt;(); // 👈 本身
List&lt;? extends TextView&gt; textViews = new ArrayList&lt;Button&gt;(); // 👈 直接子类
List&lt;? extends TextView&gt; textViews = new ArrayList&lt;RadioButton&gt;(); // 👈 间接子类
</code></pre>
<p>一般集合类都包括了get 和add两种操作，比如java中的list,</p>
<pre><code class="language-java">List&lt;? extends TextView&gt; textViews = new ArrayList&lt;Button&gt;();
TextView textView = textViews.get(0); // 👈 get 可以
textViews.add(textView);
//             👆 add 会报错，no suitable method found for add(TextView)
</code></pre>
<p>因为?extends TextView 这个泛型类型是未知的，但是肯定是textview的子类，get出来能够赋值给textview是没问题的，但是add就不能确定添加的是什么类型了。</p>
<p>List&lt;?&gt;其实就是List&lt;? extends Object&gt; 的缩写。</p>
<p>所以用了 ？extends  通配符的List，只能够向外提供数据被消费。</p>
<p>? super叫下界通配符，可以使java泛型具有逆变性。</p>
<p>这个super限制了通配符的子类型，所以叫下界。</p>
<p>通配符？表示 List的泛型类型是一个未知类型。</p>
<p>super限制了这个未知类型的下界，也就是泛型类型必须满足这个super的限制条件。</p>
<p>super 也一样包括下界本身，同样支持interface</p>
<p>所以下面写法都可以：</p>
<pre><code class="language-java">List&lt;? super Button&gt; buttons = new ArrayList&lt;Button&gt;(); // 👈 本身
List&lt;? super Button&gt; buttons = new ArrayList&lt;TextView&gt;(); // 👈 直接父类
List&lt;? super Button&gt; buttons = new ArrayList&lt;Object&gt;(); // 👈 间接父类
</code></pre>
<pre><code class="language-java">List&lt;? super Button&gt; buttons = new ArrayList&lt;TextView&gt;();
Object object = buttons.get(0); // 👈 get 出来的是 Object 类型
Button button = ...
buttons.add(button); // 👈 add 操作是可以的
</code></pre>
<p>java泛型本身是不支持协变和逆变的。</p>
<p>可以通过泛型通配符？extend 来支持协变，但是只能读取不能修改，也就是不能往泛型集合里添加元素，如果是删除或者清空是可以的。</p>
<p>可以通过泛型通配符？super来支持逆变，但是只能修改不能读取，这里的不能读取就是指不能按照泛型类型读取。</p>
<p>和java泛型一样，kotlin中的泛型本身也是不可变得。</p>
<p>使用关键字out来支持协变，等同于java中的上界通配符 ？extend</p>
<p>使用关键字in 来支持逆变，等同于java中的下界通配符？super</p>
<p>换了个写法但是作用是完全一样的。</p>
<pre><code class="language-kotlin">var textViews: List&lt;out TextView&gt;
var textViews: List&lt;in TextView&gt;
</code></pre>
<p>声明处的out和in</p>
<p>可以在声明类的时候，给泛型符号加上out,表明泛型参数T只会用来输出，在使用的时候就不用额外加out了，in也是一样的道理。</p>
<pre><code class="language-kotlin">class Producer&lt;out T&gt; {
    fun produce(): T {
        ...
    }
}

val producer: Producer&lt;TextView&gt; = Producer&lt;Button&gt;() // 👈 这里不写 out 也不会报错
val producer: Producer&lt;out TextView&gt; = Producer&lt;Button&gt;() // 👈 out 可以但没必要
</code></pre>
<p>java中单个？也能作为泛型通配符使用，相当于？extends Object。</p>
<p>kotlin中有等效写法 * ，相当于 out Any</p>
<p>java中声明类或者接口时，可以使用extends来设置边界，将泛型类型参数限制为某个类型的子集。</p>
<pre><code class="language-java">//                👇  T 的类型必须是 Animal 的子类型
class Monster&lt;T extends Animal&gt;{
}
</code></pre>
<p>这里并么有？</p>
<p>而且这个边界可以设置多个，用&amp;符号连接：</p>
<pre><code class="language-java">//                            👇  T 的类型必须同时是 Animal 和 Food 的子类型
class Monster&lt;T extends Animal &amp; Food&gt;{ 
}
</code></pre>
<p>kotlin里只是把extends换成了 ：</p>
<pre><code class="language-kotlin">class Monster&lt;T : Animal&gt;
</code></pre>
<p>设置多个边界：</p>
<pre><code class="language-kotlin">class Monster&lt;T&gt; where T : Animal, T : Food
</code></pre>
<p>由于java中的泛型存在类型擦除的情况，任何在运行时需要知道泛型确切类型信息的操作都没用了。</p>
<pre><code class="language-java">&lt;T&gt; void printIfTypeMatch(Object item) {
    if (item instanceof T) { // 👈 IDE 会提示错误，illegal generic type for instanceof
        System.out.println(item);
    }
}
</code></pre>
<p>kotlin也一样</p>
<pre><code class="language-kotlin">fun &lt;T&gt; printIfTypeMatch(item: Any) {
    if (item is T) { // 👈 IDE 会提示错误，Cannot check for instance of erased type: T
        println(item)
    }
}
</code></pre>
<p>java的解决办法通常是额外传递一个Class<T>类型的参数，然后通过isInstance方法来检查。</p>
<pre><code class="language-java">&lt;T&gt; void check(Object item, Class&lt;T&gt; type) {
    if (type.isInstance(item)) {
               👆
        System.out.println(item);
    }
}
</code></pre>
<p>kotlin中同样可以这么解决，不过还有更方便的做法：使用关键字reifield配合inline来解决：</p>
<pre><code class="language-kotlin">inline fun &lt;reified T&gt; printIfTypeMatch(item: Any) {
    if (item is T) { // 👈 这里就不会在提示错误了
        println(item)
    }
}
</code></pre>
<p>关于泛型，kotlin和java的两个不同：</p>
<p>1.java中数组是支持协变的，而kotlin中的数组Array不支持协变。因为在kotlin中数组是用Array类来表示的，这个Array类使用泛型就和集合类一样，所以不支持协变。</p>
<p>2.java中的List接口不支持协变，而kotlin中的list接口支持协变。java的List需要使用泛型通配符来解决。在kotlin里，实际上MutableList接口才相当于java的List。Kotlin中的List接口实现了只读操作，没有写操作，所以不会有类型安全的问题，自然可以支持协变。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记三-相对Java更方便的]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-3/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-3/">
        </link>
        <updated>2020-04-30T02:26:15.000Z</updated>
        <content type="html"><![CDATA[<p>次构造器：</p>
<pre><code class="language-kotlin">class User {
    var name: String
    constructor(name: String) {
        this.name = name
    }
}
</code></pre>
<p>主构造器：</p>
<pre><code class="language-kotlin">class User constructor(name: String) {
    //                  👇 这里与构造器中的 name 是同一个
    var name: String = name
}
</code></pre>
<p>在kotlin中一个类最多只能有一个主构造器，也可以没有，次级构造器没有个数限制</p>
<p>主构造器中的参数除了可以在类的属性中使用，还可以在init代码块中使用：</p>
<pre><code class="language-kotlin">class User constructor(name: String) {
    var name: String
    init {
        this.name = name
    }
}
</code></pre>
<p>其中init代码块是紧跟在主构造器之后执行的，这是因为主构造器本身没有代码体。</p>
<p>另外，如果类中有主构造器，那么其他次级构造器都需要通过this关键字调用主构造器。不然就会编译报错。因为创建类的对象时，不管使用哪个构造器，都需要主构造器的参与；在类的初始化过程中，首先执行的就是主构造器。</p>
<pre><code class="language-kotlin">class User constructor(var name: String) {
                                   // 👇  👇 直接调用主构造器
    constructor(name: String, id: Int) : this(name) {
    }
                                                // 👇 通过上一个次构造器，间接调用主构造器
    constructor(name: String, id: Int, age: Int) : this(name, id) {
    }
}
</code></pre>
<p>通常情况下，主构造器中的constructor关键字可以省略：</p>
<pre><code class="language-kotlin">class User(name: String) {
    var name: String = name
}
</code></pre>
<p>但有些场景，constructor是不可以省略的，例如在主构造器上使用可见性修饰符或者注解</p>
<pre><code class="language-kotlin">class User private constructor(name: String) {
//           👆 主构造器被修饰为私有的，外部就无法调用该构造器
}
</code></pre>
<p>其实还可以在主构造器中直接声明属性：</p>
<pre><code class="language-kotlin">class User(var name: String) {
}
// 等价于：
class User(name: String) {
  var name: String = name
}
</code></pre>
<p>：可以理解为依赖</p>
<p>函数简化：</p>
<p>使用=连接返回值</p>
<pre><code class="language-kotlin">fun area(width: Int, height: Int): Int {
    return width * height
}
</code></pre>
<p>这种只有一行的代码，可以这样写</p>
<pre><code class="language-kotlin">fun area(width: Int, height: Int): Int = width * height
</code></pre>
<p>因为kotlin有类型推断，所以还可以更简洁</p>
<pre><code class="language-kotlin">fun area(width: Int, height: Int) = width * height
</code></pre>
<p>对于没有返回值的，可以理解为返回值是Unit:</p>
<pre><code class="language-kotlin">fun sayHi(name: String) = println(&quot;Hi &quot; + name)
</code></pre>
<p>参数默认值：</p>
<p>java中的重载在kotlin中有一种更简单的方式，就是参数默认值</p>
<p>eg:java</p>
<pre><code class="language-java">public void sayHi(String name) {
    System.out.println(&quot;Hi &quot; + name);
}

public void sayHi() {
    sayHi(&quot;world&quot;); 
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">fun sayHi(name: String = &quot;world&quot;) = println(&quot;Hi &quot; + name)
</code></pre>
<p>这里的world就是参数name的默认值，当调用该参数时不传参数，就会使用该默认值。</p>
<p>等价于上面java的重载方法。</p>
<pre><code class="language-kotlin">sayHi(&quot;kaixue.io&quot;)
sayHi() // 使用了默认值 &quot;world&quot;
</code></pre>
<p>但是参数默认值调用时也有限制的。</p>
<pre><code class="language-kotlin">fun sayHi(name: String = &quot;world&quot;, age: Int) {
    ...
}

sayHi(10)
//    👆 这时想使用默认值进行调用，IDE 会报以下两个错误
// The integer literal does not conform to the expected type String
// No value passed for parameter 'age'
</code></pre>
<p>命名参数：</p>
<pre><code class="language-kotlin">fun sayHi(name: String = &quot;world&quot;, age: Int) {
    ...
}
      👇   
sayHi(age = 21)
</code></pre>
<p>这才是正确写法，需要显式指定参数age的名称，这就是命名参数。kotlin中每一个函数参数都可以作为命名参数。</p>
<pre><code class="language-kotlin">fun sayHi(name: String = &quot;world&quot;, age: Int, isStudent: Boolean = true, isFat: Boolean = true, isTall: Boolean = true) {
    ...
}
</code></pre>
<p>调用时可以这样</p>
<pre><code class="language-kotlin">sayHi(name = &quot;wo&quot;, age = 21, isStudent = false, isFat = true, isTall = false)
</code></pre>
<p>与命名参数相对的一个概念被称为未知参数，也就是按位置顺序进行参数填写。</p>
<p>当一个函数被调用时，如果混用位置参数与命名参数，那么所有的位置参数都应该放在第一个命名参数之前。</p>
<pre><code class="language-kotlin">fun sayHi(name: String = &quot;world&quot;, age: Int) {
    ...
}

sayHi(name = &quot;wo&quot;, 21) // 👈 IDE 会报错，Mixing named and positioned arguments is not allowed
sayHi(&quot;wo&quot;, age = 21) // 👈 这是正确的写法
</code></pre>
<p>本地函数（嵌套函数）</p>
<p>eg:</p>
<pre><code class="language-kotlin">fun login(user: String, password: String, illegalStr: String) {
    // 验证 user 是否为空
    if (user.isEmpty()) {
        throw IllegalArgumentException(illegalStr)
    }
    // 验证 password 是否为空
    if (password.isEmpty()) {
        throw IllegalArgumentException(illegalStr)
    }
}
</code></pre>
<p>检查参数这部分可以抽取为一个单独的函数，并且又不想对外暴露，可以用到嵌套函数。</p>
<pre><code class="language-kotlin">fun login(user: String, password: String, illegalStr: String) {
           👇 
    fun validate(value: String, illegalStr: String) {
      if (value.isEmpty()) {
          throw IllegalArgumentException(illegalStr)
      }
    }
   👇
    validate(user, illegalStr)
    validate(password, illegalStr)
}
</code></pre>
<p>重复的验证逻辑就放进了嵌套函数validate中，并且login函数外的其他地方无法访问这个嵌套函数的。</p>
<p>因为嵌套函数是可以访问它外部的所有变量或者常量，比如类中的属性、当前函数中的参数与变量等。</p>
<p>可以改进下：</p>
<pre><code class="language-kotlin">fun login(user: String, password: String, illegalStr: String) {
    fun validate(value: String) {
        if (value.isEmpty()) {
                                              👇
            throw IllegalArgumentException(illegalStr)
        }
    }
    validate(user)
    validate(password)
}
</code></pre>
<p>字符串</p>
<p>kotlin可以和java一样通过+拼接字符串，变量较多时，java使用的是String.format</p>
<pre><code class="language-java">System.out.print(String.format(&quot;Hi %s&quot;, name));
</code></pre>
<p>kotlin更方便的写法：</p>
<pre><code class="language-kotlin">val name = &quot;world&quot;
//         👇 用 '$' 符号加参数的方式
println(&quot;Hi $name&quot;)
</code></pre>
<p>除了变量，$后还可以跟表达式，但要用{}包起来</p>
<pre><code class="language-kotlin">val name = &quot;world&quot;
println(&quot;Hi ${name.length}&quot;) 
</code></pre>
<p>字符串模板还支持转义字符，比如\n 进行换行操作：</p>
<pre><code class="language-kotlin">val name = &quot;world!\n&quot;
println(&quot;Hi $name&quot;) // 👈 会多打一个空行
</code></pre>
<p>raw string(原生字符串)</p>
<p>有时候不想写过多转义字符，就可以通过原生字符串实现</p>
<p>用法就是使用一对 “”“ 将字符串括起来</p>
<pre><code class="language-kotlin">val name = &quot;world&quot;
val myName = &quot;kotlin&quot;
           👇
val text = &quot;&quot;&quot;
      Hi $name!
    My name is $myName.\n
&quot;&quot;&quot;
println(text)
</code></pre>
<p>注意点：</p>
<p>\n并不会被转义</p>
<p>最后输出的内容与写的内容完全一致，包括实际的换行</p>
<p>$符号引用变量仍然生效</p>
<p>输出结果：</p>
<pre><code>     Hi world!
    My name is kotlin.\n
</code></pre>
<p>对齐方式看起来不太优雅，原生字符串还可以通过trimMargin()函数去除每行前面的空格：</p>
<pre><code class="language-kotlin">val text = &quot;&quot;&quot;
     👇 
      |Hi world!
    |My name is kotlin.
&quot;&quot;&quot;.trimMargin()
println(text)
</code></pre>
<p>输出结果：</p>
<pre><code>Hi world!
My name is kotlin.
</code></pre>
<p>这里trimMargin的注意点：</p>
<p>|符号为默认的边界前缀，前面只能有空格，否则不会生效</p>
<p>输出时|符号以及它前面的空格都会被删除</p>
<p>边界前缀还可以使用其他字符，比如trimMargin(&quot;/&quot;),只不过上方的代码使用的是参数默认值的调用方式。</p>
<p>数组和集合</p>
<p>数组和集合的操作符</p>
<pre><code class="language-kotlin">val intArray = intArrayOf(1, 2, 3)
val strList = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>
<p>forEach:遍历每一个元素</p>
<pre><code class="language-kotlin">intArray.forEach { i -&gt;
    print(i + &quot; &quot;)
}
// 输出：1 2 3 
</code></pre>
<p>filter: 对每一个元素进行过滤操作，如果lambda表达式中的条件成立则留下该元素，否则剔除，最终生成新的集合</p>
<pre><code class="language-kotlin">// [1, 2, 3]
      ⬇️
//  {2, 3}

//            👇 注意，这里变成了 List
val newList: List = intArray.filter { i -&gt;
    i != 1 // 👈 过滤掉数组中等于 1 的元素
}
</code></pre>
<p>map:遍历每个元素并执行给定表达式，最终形成新的集合</p>
<pre><code class="language-kotlin">//  [1, 2, 3]
       ⬇️
//  {2, 3, 4}

val newList: List = intArray.map { i -&gt;
    i + 1 // 👈 每个元素加 1
}
</code></pre>
<p>flatMap: 遍历每个元素，并为每个元素创建新的集合，最终合并到一个集合里</p>
<pre><code class="language-kotlin">//          [1, 2, 3]
               ⬇️
// {&quot;2&quot;, &quot;a&quot; , &quot;3&quot;, &quot;a&quot;, &quot;4&quot;, &quot;a&quot;}

intArray.flatMap { i -&gt;
    listOf(&quot;${i + 1}&quot;, &quot;a&quot;) // 👈 生成新集合
}
</code></pre>
<p>除了数组和集合，kotlin里还有一种常见的数据类型:Range</p>
<p>Range</p>
<p>java中并没有range的概念，kotlin里的range表示区间的意思，也就是范围。区间的常见写法：</p>
<pre><code class="language-kotlin">val range: IntRange = 0..1000 
</code></pre>
<p>这里的0..1000就表示从 0到1000的范围，包括1000，[0,1000]。除了IntRange还有CharRange，LongRange</p>
<p>kotlin里没有纯的开区间的定义，不过有半开区间的定义：</p>
<pre><code class="language-kotlin">val range: IntRange = 0 until 1000 
</code></pre>
<p>这个代表[0,1000),不包含1000</p>
<p>Range这个东西，天生就是用来遍历的</p>
<pre><code class="language-kotlin">val range = 0..1000
//     👇 默认步长为 1，输出：0, 1, 2, 3, 4, 5, 6, 7....1000,
for (i in range) {
    print(&quot;$i, &quot;)
}
</code></pre>
<p>这里in关键字可以与for循环结合使用，表示挨个遍历range中的值。</p>
<p>除了使用默认的步长1，还可以通过step设置步长：</p>
<pre><code class="language-kotlin">val range = 0..1000
//               👇 步长为 2，输出：0, 2, 4, 6, 8, 10,....1000,
for (i in range step 2) {
    print(&quot;$i, &quot;)
}
</code></pre>
<p>以上是递增区间，kotlin还提供了递减区间downTo，不过递减没有半开区间的用法：</p>
<pre><code class="language-kotlin">//            👇 输出：4, 3, 2, 1, 
for (i in 4 downTo 1) {
    print(&quot;$i, &quot;)
}
</code></pre>
<p>4 downTo 1 就表示递减的闭区间[4,1]。这里的downTo以及上面的step都叫做中缀表达式。</p>
<p>Sequence,又叫做惰性集合操作。</p>
<pre><code class="language-kotlin">val sequence = sequenceOf(1, 2, 3, 4)
val result: Sequence&lt;Int&gt; = sequence
    .map { i -&gt;
        println(&quot;Map $i&quot;)
        i * 2 
    }
    .filter { i -&gt;
        println(&quot;Filter $i&quot;)
        i % 3  == 0 
    }
👇
println(result.first()) // 👈 只取集合的第一个元素
</code></pre>
<p>惰性的概念首先就是说在「👇」标注之前的代码运行时不会立即执行，它只是定义了一个执行流程，只有 <code>result</code> 被使用到的时候才会执行。</p>
<p>当「👇」的 <code>println</code> 执行时数据处理流程是这样的：</p>
<ul>
<li>取出元素 1 -&gt; map 为 2 -&gt; filter 判断 2 是否能被 3 整除</li>
<li>取出元素 2 -&gt; map 为 4 -&gt; filter 判断 4 是否能被 3 整除</li>
<li>...</li>
</ul>
<p>惰性指当出现满足条件的第一个元素的时候，<code>Sequence</code> 就不会执行后面的元素遍历了，即跳过了 8 的遍历。</p>
<p>而List是没有惰性的：声明之后立即执行。</p>
<p>Sequence这种类似懒加载的实现有以下优点：</p>
<p>一旦满足遍历退出的条件，就可以省略后续不必要的遍历过程。</p>
<p>像List这种实现iterable接口的集合类，每调用一次函数就会生成一个iterable，下个函数再基于新的iterable执行，每次函数调用产生的临时iterable会导致额外的内存消耗，而Sequence在整个流程只有一个。</p>
<p>所以，Sequence这种数据类型可以在数据量比较大或者数据量未知的时候，作为流式处理的解决方案。</p>
<p>条件控制</p>
<p>kotlin中对条件控制进行了许多的优化以及改进。</p>
<p>java if/else 写法：</p>
<pre><code class="language-java">int max;
if (a &gt; b) {
    max = a;
} else {
    max = b;
}
</code></pre>
<p>kotlin中，也可以这样写，不过kotlin中if语句还可以作为一个表达式赋值给变量：</p>
<pre><code class="language-kotlin">val max = if (a &gt; b) a else b
</code></pre>
<p>kotlin中弃用了三元运算符（条件？然后：否则），可以用if/else来代替它。</p>
<p>if/else也可以加入代码块，最后一行会作为结果返回：</p>
<pre><code class="language-kotlin">val max = if (a &gt; b) {
    println(&quot;max:a&quot;)
    a // 👈 返回 a
} else {
    println(&quot;max:b&quot;)
    b // 👈 返回 b
}
</code></pre>
<p>在java中，用switch来判断变量与一系列中的某个值是否相等；</p>
<pre><code class="language-java">switch (x) {
    case 1: {
        System.out.println(&quot;1&quot;);
        break;
    }
    case 2: {
        System.out.println(&quot;2&quot;);
        break;
    }
    default: {
        System.out.println(&quot;default&quot;);
    }
}
</code></pre>
<p>在kotlin中变成了when</p>
<pre><code class="language-kotlin">when (x) {
   👇
    1 -&gt; { println(&quot;1&quot;) }
    2 -&gt; { println(&quot;2&quot;) }
   👇
    else -&gt; { println(&quot;else&quot;) }
}
</code></pre>
<p>这里与java相比的不同点:</p>
<p>省略了case和break,kotlin自动为每个分支加上了break的功能，防止像java写错；</p>
<p>java默认的是default,kotlin则是else</p>
<p>与if/else一样，when也可以作为表达式进行使用，分支中最后一行的结果作为返回值，这样操作的话就必须要有else分支，这样才能保证无论怎样都有值返回，除非已经列出了所有情况。</p>
<pre><code class="language-kotlin">val value: Int = when (x) {
    1 -&gt; { x + 1 }
    2 -&gt; { x * 2 }
    else -&gt; { x + 5 }
}
</code></pre>
<p>在java中，当多种情况之下执行同一份代码时，</p>
<pre><code class="language-kotlin">switch (x) {
    case 1:
    case 2: {
        System.out.println(&quot;x == 1 or x == 2&quot;);
        break;
    }
    default: {
        System.out.println(&quot;default&quot;);
    }
}
</code></pre>
<p>kotlin中，是用，隔开</p>
<pre><code class="language-kotlin">when (x) {
    👇
    1, 2 -&gt; print(&quot;x == 1 or x == 2&quot;)
    else -&gt; print(&quot;else&quot;)
}
</code></pre>
<p>使用in检测是否在一个区间或者集合中：</p>
<pre><code class="language-kotlin">when (x) {
   👇
    in 1..10 -&gt; print(&quot;x 在区间 1..10 中&quot;)
   👇
    in listOf(1,2) -&gt; print(&quot;x 在集合中&quot;)
   👇 // not in
    !in 10..20 -&gt; print(&quot;x 不在区间 10..20 中&quot;)
    else -&gt; print(&quot;不在任何区间上&quot;)
}
</code></pre>
<p>或者使用is进行特定类型的检测：</p>
<pre><code class="language-kotlin">val isString = when(x) {
    👇
    is String -&gt; true
    else -&gt; false
}
</code></pre>
<p>还可以省略when后面的参数，每一个分支条件都可以是一个布尔表达式</p>
<pre><code class="language-kotlin">when {
   👇
    str1.contains(&quot;a&quot;) -&gt; print(&quot;字符串 str1 包含 a&quot;)
   👇
    str2.length == 3 -&gt; print(&quot;字符串 str2 的长度为 3&quot;)
}
</code></pre>
<p>当分支的判断条件为表达式时，哪一个条件先为true就执行哪个分支的代码块</p>
<p>for</p>
<p>java遍历集合或者数组：</p>
<pre><code class="language-kotlin">int[] array = {1, 2, 3, 4};
for (int item : array) {
    ...
}
</code></pre>
<p>kotlin遍历：</p>
<pre><code class="language-kotlin">val array = intArrayOf(1, 2, 3, 4)
          👇
for (item in array) {
    ...
}
</code></pre>
<p>与java的不同：</p>
<p>在kotlin中，表示单个元素的item，不用显示声名类型</p>
<p>kotlin使用的关键字是in,表示item是array里面的一个元素</p>
<p>另外，kotlin的in后面的变量可以是任何实现iterable接口的对象</p>
<p>在java另一种写for循环的方式：</p>
<pre><code class="language-kotlin">for (int i = 0; i &lt;= 10; i++) {
    // 遍历从 0 到 10
}
</code></pre>
<p>但kotlin中么有这样的写法，是这样：</p>
<pre><code class="language-kotlin">for (i in 0..10) {
    println(i)
}
</code></pre>
<p>try-catch</p>
<p>kotlin捕获异常的写法和java差不多：</p>
<pre><code class="language-kotlin">try {
    ...
}
catch (e: Exception) {
    ...
}
finally {
    ...
}
</code></pre>
<p>但是也有不同点:</p>
<p>在java中，调出一个抛出异常的方法时，需要对异常进行处理，否则就会报错</p>
<pre><code class="language-java">public class User{
    void sayHi() throws IOException {
    }
    
    void test() {
        sayHi();
        // 👆 IDE 报错，Unhandled exception: java.io.IOException
    }
}
</code></pre>
<p>但是在kotlin中，调用上方user类的sayHi方法不会报错</p>
<pre><code class="language-kotlin">val user = User()
user.sayHi() // 👈 正常调用，IDE 不会报错，但运行时会出错
</code></pre>
<p>因为kotlin中的异常是不会被检查的，只有在运行时如果sayHi抛出异常才会出错。</p>
<p>kotlin中的try-catch也可以是一个表达式，允许代码块的最后一行作为返回值。</p>
<pre><code class="language-kotlin">val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
</code></pre>
<p>?.和?:</p>
<p>?:是另外一个常用的复合符号，可以在判空时更加方便。</p>
<p>调用?.在对象非空时会执行后面的调用，对象为空时就会返回null。如果这时将该表达式赋值给一个不可空的变量：</p>
<pre><code class="language-kotlin">val str: String? = &quot;Hello&quot;
var length: Int = str?.length
//                👆 ，IDE 报错，Type mismatch. Required:Int. Found:Int?
</code></pre>
<p>因为length为不可空变量，不能让可空变量赋值给它</p>
<p>这时就可用Elvis操作符?:</p>
<pre><code class="language-kotlin">val str: String? = &quot;Hello&quot;
                             👇
val length: Int = str?.length ?: -1
</code></pre>
<p>这意思就是如果左边表达式str?.length结果为空，则返回右侧的值-1</p>
<p>Elvis操作符还有另外一种常见用法：</p>
<pre><code class="language-kotlin">fun validate(user: User) {
    val id = user.id ?: return // 👈 验证 user.id 是否为空，为空时 return 
}
// 等同于

fun validate(user: User) {
    if (user.id == null) {
        return
    }
    val id = user.id
}
</code></pre>
<p><mark>和</mark>=</p>
<p>java里==比较的如果是基本数据类型值，则判断值是否相等，如果比较的是String则表示引用地址是否相等，String字符串内容比较 是用的是equal();</p>
<pre><code class="language-java">String str1 = &quot;123&quot;, str2 = &quot;123&quot;;
System.out.println(str1.equals(str2));
System.out.println(str1 == str2); 
</code></pre>
<p>kotlin也有两张相等比较方式：</p>
<p>==：可以对基本数据类型以及String等类型进行内容比较，相当于java的equals</p>
<p>=<mark>:对引用的内存地址进行比较，相当于java中的</mark></p>
<p>也就是说 java中的equal，在kotlin中与之对应的是==</p>
<pre><code class="language-kotlin">val str1 = &quot;123&quot;
val str2 = &quot;123&quot;
println(str1 == str2) // 👈 内容相等，输出：true

val str1= &quot;字符串&quot;
val str2 = str1
val str3 = str1
print(str2 === str3) // 👈 引用地址相等，输出：true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记二-关于类和Java的不同]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-er-guan-yu-lei-he-java-de-bu-tong/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-er-guan-yu-lei-he-java-de-bu-tong/">
        </link>
        <updated>2020-04-29T08:32:38.000Z</updated>
        <content type="html"><![CDATA[<p>kotlin构造器的写法和java不一样：</p>
<p>java:</p>
<pre><code class="language-java">public class User {
    int id;
    String name;
      👇   👇
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">class User {
    val id: Int
    val name: String
         👇
    constructor(id: Int, name: String) {
 //👆 没有 public
        this.id = id
        this.name = name
    }
}
</code></pre>
<p>两点不同：java中构造器和类同名，Kotlin中则使用constructor表示；Kotlin中构造器没有public修饰，因为默认是public。</p>
<p>kotlin初始化代码块的写法和java不一样：</p>
<p>java:</p>
<pre><code class="language-java">public class User {
   👇
    {
        // 初始化代码块，先于下面的构造器执行
    }
    public User() {
    }
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">class User {
    👇
    init {
        // 初始化代码块，先于下面的构造器执行
    }
    constructor() {
    }
}
</code></pre>
<p>关于final:</p>
<p>kotlin中val和java的final类似，表示只读变量，不能修改。不同之处在于，kotlin函数参数默认是val类型，所以参数前不需要写val关键字，这样设计是为了保证参数不会被修改；而java的参数可修改，会增加出错的概率。</p>
<p>虽然val修饰的变量不能二次赋值，但是可以通过自定义变量的getter函数，让变量每次被访问时，返回动态获取的值。</p>
<p>eg:</p>
<pre><code class="language-kotlin">val size: Int
    get() { // 👈 每次获取 size 值时都会执行 items.size
        return items.size
    }
</code></pre>
<p>静态常量和静态方法：</p>
<p>java里写常量都是用static+final。但是在kotlin里，静态变量和静态方法这两个概念被去除了。</p>
<p>如果想在kotlin里像java一样直接通过类引用，就要用到companion object。</p>
<pre><code class="language-kotlin">class Sample {
    ...
       👇
    companion object {
        val anotherString = &quot;Another String&quot;
    }
}
</code></pre>
<p>Sample.anotherString.length</p>
<p>kotlin里的object，首字母小写。java中的Object在kotlin里不用了。java中的Object在Kotlin里变成了Any,和Object作用一样：所有类的基类。</p>
<p>但是 kotlin中的object不是对象，而是关键字，可以理解为单例。</p>
<pre><code class="language-kotlin">object Sample {
    val name = &quot;A name&quot;
}
</code></pre>
<p>Sample.name</p>
<p>object的意思很简单：创建一个类，并且创建一个这个类的对象。在代码中如果要使用这个对象，直接使用它的类名就可以访问。</p>
<p>所以在kotlin中创建单例很简单，class换成object就行了。</p>
<p>这种通过object实现的单例是一个饿汉式的单例，并且实现了线程安全。</p>
<p>object也可以继承别的类，实现接口。</p>
<p>为什么 object 可以实现接口呢？简单来讲 object 其实是把两步合并成了一步，既有 class 关键字的功能，又实现了单例，这样就容易理解了。</p>
<p>匿名类：</p>
<p>java:</p>
<pre><code class="language-java">ViewPager.SimpleOnPageChangeListener listener = new ViewPager.SimpleOnPageChangeListener() {
    @Override // 👈
    public void onPageSelected(int position) {
        // override
    }
};
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">val listener = object: ViewPager.SimpleOnPageChangeListener() {
    override fun onPageSelected(position: Int) {
        // override
    }
}  
</code></pre>
<p>和java创建匿名类的方式很相似，只不过把new换成了object:</p>
<p>object:修饰的都是接口或者抽象类。</p>
<p>companion object :</p>
<p>object修饰的对象中的变量和函数都是静态的。所以如果想让类中的一部分函数和变量成为静态就要用到companion object(伴生对象)。</p>
<pre><code class="language-kotlin">class A {
          👇
    object B {
        var c: Int = 0
    }
}
</code></pre>
<p>A.B.c</p>
<p>也可以这样写</p>
<pre><code class="language-kotlin">class A {
       👇
    companion object B {
        var c: Int = 0
    }
}
</code></pre>
<p>companion可以理解为伴随、伴生，表示修饰的对象和外部类绑定。</p>
<p>但是有一个小限制：一个类中最多只能有一个伴生对象，但可以有多个嵌套对象。</p>
<p>也因为这个限制，所以调用的时候可以省掉对象名：A.c</p>
<p>所以有companion修饰时，对象的名字也可省略掉：</p>
<pre><code class="language-kotlin">class A {
                // 👇 B 没了
    companion object {
        var c: Int = 0
    }
}
</code></pre>
<p>静态初始化：</p>
<p>java中的静态变量和方法,kotlin都放在了companion object中。因此java中的静态初始化在kotlin中自然也是放在companion object中。</p>
<pre><code class="language-kotlin">class Sample {
       👇
    companion object {
         👇
        init {
            ...
        }
    }
}
</code></pre>
<p>顶层声明（top-level property/function）:</p>
<p>就是把属性和函数的声明不写在class里面，这个在kotlin里是允许的：</p>
<pre><code class="language-kotlin">package com.hencoder.plus

// 👇 属于 package，不在 class/object 内
fun topLevelFuncion() {
}
</code></pre>
<p>topLevelFunction()</p>
<p>这样写的属性和函数，不属于任何class,而是直接属于package，它和静态变量、函数一样是全局的，直接用，都不需要写类名。</p>
<p>所以对于object、companion object 、top-level：</p>
<p>如果想写工具类的功能，直接创建文件，写top-level顶层函数。</p>
<p>如果要继承别的类或者实现接口，就用object或者companion object。</p>
<p>常量：</p>
<p>java:</p>
<pre><code class="language-java">public class Sample {
            👇     👇
    public static final int CONST_NUMBER = 1;
}
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">class Sample {
    companion object {
         👇                  // 👇
        const val CONST_NUMBER = 1
    }
}

const val CONST_SECOND_NUMBER = 2
</code></pre>
<p>kotlin用const 修饰常量；kotlin的常量必须声明在对象（包括伴生对象）或者顶层中，因为常量是静态的。</p>
<p>而且kotlin中只有基本类型和String类型可以声明成常量，而java里 static  final还可以修饰对象。但是java中可以是伪常量。</p>
<pre><code class="language-java">public class User {
    int id; // 👈 可修改
    String name; // 👈 可修改
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
</code></pre>
<pre><code class="language-java">static final User user = new User(123, &quot;Zhangsan&quot;);
</code></pre>
<pre><code class="language-java">user.name = &quot;Lisi&quot;;
</code></pre>
<p>可以通过上面的方式改变它内部的值。而kotlin的常量因为限制类型必须是基本类型，所以不存在这种问题，更符合常量的定义。</p>
<p>数组</p>
<p>声明一个string数组：</p>
<p>java:</p>
<pre><code class="language-java">String[] strs = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">val strs: Array&lt;String&gt; = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>
<p>取值和修改：</p>
<pre><code class="language-kotlin">println(strs[0])
   👇      👆
strs[1] = &quot;B&quot;
</code></pre>
<p>和java方式一样。</p>
<p>kotlin中数组不支持协变，子类数组对象不能赋值给父类的数组变量。但是java数组支持协变。</p>
<p>集合</p>
<p>Kotlin和Java一样有三种集合类型：List、Set和Map，</p>
<p>java:</p>
<pre><code class="language-java">List&lt;String&gt; strList = new ArrayList&lt;&gt;();
strList.add(&quot;a&quot;);
strList.add(&quot;b&quot;);
strList.add(&quot;c&quot;); // 👈 添加元素繁琐
</code></pre>
<p>kotlin:</p>
<pre><code class="language-kotlin">val strList = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>
<p>kotlin创建list，类似创建数组的代码。kotlin里的list支持协变。可以把子类的list赋值给父类list变量。但是java list不支持协变。</p>
<p>和List类似，Set同样具有协变特性。</p>
<p>java创建map:</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);
map.put(&quot;key4&quot;, 3);
</code></pre>
<p>kotlin创建map:</p>
<pre><code class="language-kotlin">val map = mapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2, &quot;key3&quot; to 3, &quot;key4&quot; to 3)
</code></pre>
<p>mapOf的每一个参数表示一个键值对，to表示将键和值关联，这个叫中缀表达式。</p>
<p>kotlin中的map除了和java一样可以使用get()根据键获取对应的值，还可以使用方括号的方式获取：</p>
<pre><code class="language-kotlin">val value1 = map.get(&quot;key1&quot;)
               👇
val value2 = map[&quot;key2&quot;]
</code></pre>
<p>类似的，kotlin中也可以用方括号的方式改变map中的值</p>
<pre><code class="language-kotlin">val map = mutableMapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2)
    👇
map.put(&quot;key1&quot;, 2)
   👇
map[&quot;key1&quot;] = 2  
</code></pre>
<p>可变集合/不可变集合</p>
<p>mapOf()创建的map不可以修改值，mutableMapOf()创建的map才可以修改。</p>
<p>Kotlin中的集合分为两种类型：只读和可变的。只读有两层意思：</p>
<p>集合的size不可变；集合中的元素值不可变。</p>
<p>有mutable前缀的函数创建的是可变的集合，没有就是不可变的集合。不过可以通过toMutable*()系列函数转换成可变的函数，不过该方法返回的是新集合，原集合还是不可变的。</p>
<p>Sequence:</p>
<p>kotlin的容器类型sequence,和iterable一样。</p>
<pre><code class="language-kotlin">sequenceOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>
<p>使用iterable创建:</p>
<pre><code class="language-kotlin">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
list.asSequence()
</code></pre>
<p>可见性修饰符</p>
<p>kotlin有四种可见性修饰符：</p>
<p>public:公开，可见性最大，哪里都可以引用</p>
<p>private:私有，可见性最小，根据声明位置不同可分为类中可见和文件中可见。</p>
<p>protected:保护，相当于private+子类可见</p>
<p>internal:内部，仅对module内可见。</p>
<p>相比java少了一个default（包内可见）修饰符，多了一个internal(module内可见)修饰符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin学习笔记一-基础写法和Java的区别]]></title>
        <id>https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-1-ji-chu-xie-fa-he-java-de-qu-bie/</id>
        <link href="https://rhizophora.github.io/post/kotlin-xue-xi-bi-ji-1-ji-chu-xie-fa-he-java-de-qu-bie/">
        </link>
        <updated>2020-04-28T08:17:14.000Z</updated>
        <content type="html"><![CDATA[<p>kotlin结尾不需要分号</p>
<p>kotlin声明变量是需要初始化，否则会报错，除非声明称抽象的（kotlin里变量可以声明成抽象的）。因为kotlin的变量是没有默认值的。</p>
<p>因为kotlin有空安全设计，所以不能赋值为null。对应java中的注解@NonNull，不过java里是提示警告，kotlin里会直接报错，拒绝编译。kotlin里所有的变量默认不允许为空。</p>
<p>如果要解除非空限制，就在类型右边加个？，代表这个值可能为空。var i:String?=null</p>
<p>加？的写法，在kotlin里称为可空类型。不过对于可空引用的调用会导致空指针的异常，编译就会报错，即使加了 i!=null 的判断。这个报错的意思就是你即使检查了非空也不能保证下面调用的时候还是非空，有可能多线程的情况下，其他线程把它改成空的。</p>
<p>所以解决这个问题就是 . 改为 ?.</p>
<p>i?.length</p>
<p>这样写会对变量做一次非空确认再调用方法，做到线程安全。还有种是 !!.</p>
<p>这样写就代表变量一定是空的，不用编译器检查，后果自己承担。</p>
<p>关于空安全，所谓可空不可空，关注的都是使用的时候，就是这个变量在使用的时候是否可能为空</p>
<p>kotlin变量默认是public的</p>
<p>kotlin里属性的getter/setter的函数,和java的区别：</p>
<p>​	getter/setter函数有了专门的关键字get/set</p>
<p>​	getter/setter函数位于var所声明的变量下面</p>
<p>​	setter函数参数是value</p>
<p>​	set/get里属性值名称成了field</p>
<p>kotlin中的类默认是public ，类的继承在kotlin是：，其实：不仅可以表示继承，还可以表示java中的implement。</p>
<p>java中的override是注解，kotlin中的override是关键字。kotlin的override函数的可见性继承自父类的。</p>
<p>Kotlin中的类默认是final的，所以无法继承，与java类默认权限不一致。但是可以通过加上关键字open解除final限制，就可以继承了。open没有父类到子类的遗传性，但是override是有遗传性的，可以遗传权限。如果要关闭override的遗传性，在前面加上final关键字就可以。</p>
<p>kotlin实例化一个对象，不需要new关键字</p>
<p>类型的判断和强转</p>
<p>java里，需要先试用instanceof关键字判断类型再通过强转来调用</p>
<pre><code class="language-java">void main() {
    Activity activity = new NewActivity();
    if (activity instanceof NewActivity) {
        ((NewActivity) activity).action();
    }
}
</code></pre>
<p>kotlin里也有类似的，使用is关键字进行类型判断，并且因为编译器能够进行类型推断，可以帮助省略强转的写法:</p>
<pre><code class="language-kotlin">fun main() {
    var activity: Activity = NewActivity()
    if (activity is NewActivity) {
        // 👇的强转由于类型推断被省略了
        activity.action()
    }
}
</code></pre>
<p>也可以不进行类型判断，直接进行强转调用。可用as关键字</p>
<pre><code class="language-kotlin">fun main() {
    var activity: Activity = NewActivity()
    (activity as NewActivity).action()
}
</code></pre>
<p>但是这样写，如果强转成一个错误的类型，程序就会抛异常。</p>
<p>如果要进行安全的强转，可以用as?来解决：</p>
<pre><code class="language-kotlin">fun main() {
    var activity: Activity = NewActivity()
    // 👇'(activity as? NewActivity)' 之后是一个可空类型的对象，所以，需要使用 '?.' 来调用
    (activity as? NewActivity)?.action()
}
</code></pre>
<p>这意思就是如果强转成功就执行之后的调用，如果强转不成功就不执行。</p>
<p>思考这三个写法的区别</p>
<pre><code class="language-kotlin">activity as? NewActivity
activity as NewActivity?
activity as? NewActivity?
</code></pre>
<p>解：第一种as?是代表强转可能会失败，但是不会抛出异常；</p>
<p>第二种 NewActivity? 代表 as转换后的结果是可空的，所以需要用NewActivity?变量去接收这个结果；</p>
<p>第三种 as? NewActivity? 重点是NewActivity?,所以和第二种写法效果是一样的。</p>
]]></content>
    </entry>
</feed>